using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Speech.Recognition;
using System.Speech.Synthesis;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Windows.Forms;

namespace StartForm {
    /// <summary>
    /// Represents, handles, and runs a joke malware.
    /// </summary>
    public class Joke {
        /// <summary>
        /// The start form that created this.
        /// </summary>
        private readonly Start parentForm;

        // Used for random number generation throughout here.
        private readonly Random rand = new();

        /// <summary>
        /// A invisible Form used to draw random lines onto the user's screen.
        /// </summary>
        private readonly Form drawing = new() {
            BackColor = Color.White,
            TransparencyKey = Color.White,
            FormBorderStyle = FormBorderStyle.None,
            Bounds = Screen.PrimaryScreen.Bounds,
            ShowInTaskbar = false,
            TopMost = true
        };
        /// <summary>
        /// The random lines being drawn represented with GraphicsPaths.
        /// </summary>
        private readonly List<GraphicsPath> lines = new();

        private static readonly string newline = Environment.NewLine;

        //[DllImport("User32")]
        //private static extern int ShowWindow(int hwnd, int nCmdShow);

        /// <summary>
        /// Initializes a new joke malware.
        /// </summary>
        /// <param name="parent"></param>
        public Joke(Start parent)
        {
            parentForm = parent;

            SetupDraw();
        }

        /// <summary>
        /// Main method for Joke that uses a timer to randomly execute random methods.
        /// </summary>
        public void Run()
        {
            var timer = new System.Timers.Timer(rand.Next(120000)) {
                SynchronizingObject = parentForm
            };
            //form.CreateControl(); //_ = form.Handle;

            timer.Elapsed += new ElapsedEventHandler(async (object sender, ElapsedEventArgs e) => {
                var fun = Task.Run(() => InvokeOnThread(parentForm, rand.Next(780) switch {
                    < 110 => new Action(MoveCursor),// 0-109
                    < 165 => new Action(RotateScreen),// 110-164
                    < 275 => new Action(EditClipboard),// 165-274
                    < 330 => new Action(OpenEditor),// 275-329
                    < 385 => new Action(() => OpenCommand(rand.Next() % 2 == 0)),// 330-384
                    < 440 => new Action(OpenExplorer),// 385-439
                    < 550 => new Action(ShowPopup),// 440-549
                    < 660 => new Action(Notify),// 550-659
                    < 715 => new Action(Draw),// 660-714
                    < 770 => new Action(Speak),// 715-769
                    < 779 => new Action(Annoy),// 770-779
                    _ => throw new NotImplementedException(),
                }));
                timer.Interval = rand.Next(120000);
                await fun;
            });
            timer.Start();
        }

        /// <summary>
        /// Calls a method on the correct thread for a control.
        /// </summary>
        /// <param name="control">The control used.</param>
        /// <param name="method">The method to be called as an Action.</param>
        private static void InvokeOnThread(Control control, Action method)
        {
            if ( control.InvokeRequired ) {
                control.Invoke(new MethodInvoker(method), null);
            }
            else {
                method();
            }
        }

        /// <summary>
        /// Not Implemented Completely
        /// </summary>
        private void Hear()
        {
            var engine = parentForm.SREngine;
            engine.LoadGrammar(new DictationGrammar());
            engine.SpeechRecognized += new EventHandler<SpeechRecognizedEventArgs>((object sender, SpeechRecognizedEventArgs e) => { MessageBox.Show(e.Result.Text); });
            _ = engine.Recognize(); // does once, good. should go until something heard
        }

        /// <summary>
        /// [Not Implemented Completely] Says hello.
        /// </summary>
        private void Speak()
        {
            var synth = new SpeechSynthesizer();
            synth.SetOutputToDefaultAudioDevice();
            var pb = new PromptBuilder();
            //todo switch: tf2 voice lines
            pb.AppendText("Hellow");
            synth.Speak(pb);
        }

        /// <summary>
        /// Not Implemented
        /// </summary>
        private void MinMaxWindows()
        {
            var processes = Process.GetProcesses();
            var proc = processes[rand.Next(processes.Length)];

            //proc.Handle
            //proc.SafeHandle
            //proc.ProcessName
            //proc.Id

            //ShowWindow();
        }

        /// <summary>
        /// Sets up drawing and its events. Called in the constructor.
        /// </summary>
        private void SetupDraw()
        {
            drawing.Paint += new PaintEventHandler((object sender, PaintEventArgs e) => {
                using var pen = new Pen(Color.Black);
                foreach ( var path in lines ) {
                    e.Graphics.DrawPath(pen, path);
                }
            });

            drawing.MouseEnter += new EventHandler((object sender, EventArgs e) => {
                foreach ( var path in lines ) {
                    Point pos = Cursor.Position;

                    using var pen = new Pen(Color.Black);
                    if ( path.IsOutlineVisible(pos, pen) || path.IsVisible(pos) ) {
                        lines.Remove(path);

                        if ( !lines.Any() ) {
                            drawing.Hide();
                        }

                        drawing.Invalidate();
                        break;
                    }
                }
            });
        }

        /// <summary>
        /// Draws lines on the screen.
        /// </summary>
        private void Draw()
        {
            var gp = new GraphicsPath();
            //todo: pick random point then pick random vector (direction and distance) with end point.
            gp.AddLine(new Point(rand.Next(drawing.Width), rand.Next(drawing.Height)), new Point(rand.Next(drawing.Width), rand.Next(drawing.Height)));
            lines.Add(gp);
            if ( drawing.InvokeRequired ) {
                drawing.Invoke(new MethodInvoker(() => { drawing.Show(); }));
            }
            else {
                drawing.Show();
            }
        }

        /// <summary>
        /// Rotates the screen to one of four possible orientations.
        /// </summary>
        private void RotateScreen()
        {
            switch ( rand.Next(4) ) {
                case 0:
                    SendKeys.Send("^%{UP}");
                    break;
                case 1:
                    SendKeys.Send("^%{DOWN}");
                    break;
                case 2:
                    SendKeys.Send("^%{LEFT}");
                    break;
                case 3:
                    SendKeys.Send("^%{RIGHT}");
                    break;
            }
        }

        /// <summary>
        /// Edits the clipboard.
        /// </summary>
        private void EditClipboard()
        {
            string text = rand.Next(4) switch {
                0 => "HI!",
                1 => "hopefully whatever was in here wasn't important",
                2 => "\0",
                3 => Clipboard.GetText(TextDataFormat.Rtf) // Messes with what was already there.
                              .Replace(" ", newline)
                              .Insert(0, newline)
                              .ToUpperInvariant()
                              .ToLowerInvariant()
                              .ToUpper(),
                _ => null
            };

            Clipboard.SetText(text);
        }

        /// <summary>
        /// Not Implemented Completely
        /// </summary>
        private void KeyLock() // todo: fix - SendKey sends to app not OS
        {
            switch ( rand.Next(3) ) {
                case 0:
                    SendKeys.Send("{SCROLLLOCK}");
                    break;
                case 1:
                    SendKeys.Send("{NUMLOCK}");
                    break;
                case 2:
                    SendKeys.Send("{CAPSLOCK}");
                    break;
            }
        }

        /// <summary>
        /// Opens command prompt or powershell and may run a random command.
        /// </summary>
        /// <param name="isPS">Decides whether to open command prompt (false) or powershell (true). Defaults to false.</param>
        private async void OpenCommand(bool isPS = false) // void bad, Task good
        {
            using var proc = Process.Start(new ProcessStartInfo { FileName = isPS ? "powershell" : "cmd", RedirectStandardInput = true });

            using ( var stdin = proc.StandardInput ) {
                stdin.AutoFlush = true;

                // Picks random colors for cmd.
                if ( !isPS && rand.Next() % 2 == 0 ) {
                    int fore = rand.Next(16);
                    int back = rand.Next(16);
                    while ( fore == back ) {
                        fore = rand.Next(16);
                        back = rand.Next(16);
                    }
                    await stdin.WriteLineAsync($"color {back:x}{fore:x}");
                }

                // Picks a random command, can be nothing.
                int choice = rand.Next(6);
                if ( choice != 0 ) {
                    await stdin.WriteLineAsync(choice switch {
                        1 => $"cd /{newline}tree",
                        2 => "tree",
                        3 => $"cd /{newline}dir",
                        4 => "dir",
                        5 => "NET ACCOUNTS",
                        _ => null
                    });
                }

                // Exits the process after some time (0.5 to 30 seconds)
                await Task.Delay(rand.Next(500, 30000));
                if ( rand.Next() % 2 == 0 ) {
                    await stdin.WriteLineAsync("exit");
                }
            }

            proc.WaitForExit();
        }

        /// <summary>
        /// Displays a popup windows with random text, caption, buttons, and icon.
        /// </summary>
        private void ShowPopup()
        {
            string text = rand.Next(18) switch {
                0 => "Deleting System32",
                1 => "Windows has finished removing System32",
                2 => "Fatal error while opening FILE NAME HERE",
                3 => "System32 is corrupted or missing",
                4 => "Searching for backup file for System32",
                5 => "Allow task?",
                6 => "Unable to find backup files for System32",
                7 => "critical error",
                8 => "Reboot the computer?",
                9 => @"Failed to access data from C:\Windows\System32\",
                10 => "Fatal memory_data error, we advise to shut down Windows to prevent further damage",
                11 => "Contact Microsoft Windows support",
                12 => "Request has been sent to the support team",

                13 => "Error while opening computer",
                14 => "Unable to resolve error",
                15 => "Do you want to scan this computer?",
                16 => "Click me",
                _ => string.Empty
            };

            string caption = rand.Next(6) switch {
                0 => "Info",
                1 => "Error",
                2 => "critical error",
                3 => "Click me",
                > 3 => "",
                _ => null
            };

            var icons = Enum.GetValues<MessageBoxIcon>();

            MessageBox.Show(text, caption, (MessageBoxButtons)rand.Next(6), icons.OrderBy(e => Guid.NewGuid()).FirstOrDefault());
        }

        /// <summary>
        /// Moves the cursor to a new random location.
        /// </summary>
        private void MoveCursor()
        {
            var rect = Screen.PrimaryScreen.Bounds;
            var pos = Cursor.Position;

            int minX = -pos.X / 2;
            int minY = -pos.Y / 2;
            int maxX = (rect.Width - pos.X) / 2;
            int maxY = (rect.Height - pos.Y) / 2;
            Cursor.Position = new Point(pos.X + rand.Next(minX, maxX), pos.Y + rand.Next(minY, maxY));
        }

        /// <summary>
        /// Opens default text editor.
        /// </summary>
        private void OpenEditor()
        {
            string filepath = Path.Combine(Path.GetTempPath(), "Untitled.txt");
            if ( !File.Exists(filepath) ) {
                File.Create(filepath).Dispose();
            }

            using var proc = Process.Start(new ProcessStartInfo { FileName = "explorer", Arguments = $"\"{filepath}\"" });

            proc.WaitForExit();
        }

        /// <summary>
        /// Opens File Explorer.
        /// </summary>
        private void OpenExplorer()
        {
            using var proc = Process.Start(new ProcessStartInfo { FileName = "explorer" });
            proc.WaitForExit();
        }

        /// <summary>
        /// Shows notification with random text.
        /// </summary>
        private void Notify()
        {
            var notify = parentForm.notifyIconJ;

            notify.BalloonTipIcon = (ToolTipIcon)rand.Next(4);

            switch ( rand.Next(10) ) {
                case 0:
                    notify.BalloonTipTitle = "HEY EVERY       !";
                    notify.BalloonTipText = $"IT'S ME, SPAMTON G. SPAMTON!{newline}EV3RY BUDDY  'S FAVORITE [[Number 1 Rated Salesman1997]]";
                    break;
                case 1:
                    notify.BalloonTipTitle = "YOU WANNA BE A [Big Shot]! EAHAHAHAHAA!!";
                    notify.BalloonTipText = "[[Hyperlink blocked.]]";
                    break;
                case 2:
                    notify.BalloonTipTitle = "LET'S MAKE A DEAL.";
                    notify.BalloonTipText = "YOU HAVE TOO MUCH MONEY";
                    break;
                case 3:
                    notify.BalloonTipTitle = "THIS IS [One Purchase] YOU WILL [Regret] FOR THE REST OF YOUR LIFE!";
                    notify.BalloonTipText = "DON'T WORRY! FOR OUR [No Money Back Guaranttee]";
                    break;
                case 4:
                    notify.BalloonTipTitle = "LOOKING FOR [Irresistible Deals] THAT WILL [Blow Your Mind!?]";
                    notify.BalloonTipText = "WELL [Shut Your Mouth] BECAUSE YOU ARE [A Weakling!]";
                    break;
                case 5:
                    notify.BalloonTipTitle = "TAKE THIS DEAL AND YOU WILL [[Die]]!! IT'S THAT GOOD!!!";
                    notify.BalloonTipText = "HURRY UP AND BUY!";
                    break;
                case 6:
                    notify.BalloonTipTitle = "WAIT LOOK!! HEAR THOSE [Balloons]??? YOU ARE [1000th Customer]!!.";
                    notify.BalloonTipText = "DON'T WORRY KIDS I'M AN [HonestMan] I JUST NEED YOUR [Account Details] AND THE [Number on theB4ck]!"
                                            + newline + "THEN YOU CAN ENJ0Y EVERY [Big], EVERY [Shot], EVERY [Hyperlink Blocked], ALL YOURS";
                    break;
                case 7:
                    notify.BalloonTipTitle = "YOU [Little Sponge]! I KNEW YOU'D COME HERE [[On A Saturday Night]]!";
                    notify.BalloonTipText = "DON'T FORGET TO [Like and Subscribe] FOR MORE [Hyperlink Blocked]!";
                    break;
                case 8:
                    notify.BalloonTipTitle = "MY [[Hyperlink Blocked]].";
                    notify.BalloonTipText = "[[Designed BY The Classics You've Come To Expect! (C)1997]]";
                    break;
                case 9:
                    notify.BalloonTipTitle = "LOOKS LIKE YOU'RE [[All Alone On A Late Night?]]";
                    notify.BalloonTipText = $"WHY BE THE [[Little Sponge]] WHO HATES ITS [[$4.99]] LIFE{newline}WHEN YOU CAN BE A [[BIG SHOT!!!]]";
                    break;
                default:
                    notify.BalloonTipTitle = null;
                    notify.BalloonTipText = null;
                    break;
            }

            notify.ShowBalloonTip(1000);
        }

        /// <summary>
        /// Displays an almost unclosable window to annoy user.
        /// </summary>
        private void Annoy()
        {
            var form = new Form {
                Size = new Size(182, 132),
                TopMost = true,
                ShowInTaskbar = false,
                FormBorderStyle = FormBorderStyle.FixedToolWindow,
                StartPosition = FormStartPosition.CenterScreen
            };

            form.Controls.Add(new Label { Text = "Title", Location = new Point(12, 12), AutoSize = true });

            var eHandle = new FormClosingEventHandler((object sender, FormClosingEventArgs e) => e.Cancel = true);

            switch ( rand.Next(50) ) {
                case 0:
                    form.FormClosing += eHandle;
                    break;
                default:
                    form.FormClosed += new FormClosedEventHandler(async (object sender, FormClosedEventArgs e) => { await Task.Delay(rand.Next(150, 6001)); Annoy(); });
                    break;
            }

            var button = new Button {
                Text = "Click",
                Location = new Point(74, 42),
                AutoSize = true
            };
            button.Click += new EventHandler((object sender, EventArgs e) => { button.Hide(); form.FormClosing -= eHandle; });
            form.Controls.Add(button);

            form.Show();
        }
    }
}
