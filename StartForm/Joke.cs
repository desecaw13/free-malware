using System;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Diagnostics;
using System.ServiceProcess;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Timers;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.IO;
using System.Linq;

namespace StartForm {
    public class Joke {
        private System.Threading.Timer timer;

        private readonly Start parentForm;
        private readonly Random rand = new();
        private const int numberof = 10;

        private readonly Form drawing = new() {
            BackColor = Color.White,
            TransparencyKey = Color.White,
            FormBorderStyle = FormBorderStyle.None,
            Bounds = Screen.PrimaryScreen.Bounds,
            ShowInTaskbar = false,
            TopMost = true
        };
        private readonly List<GraphicsPath> lines = new();

        private static readonly string newline = Environment.NewLine;

        //isBackground on thread

        //[DllImport("User32")]
        //private static extern int ShowWindow(int hwnd, int nCmdShow);
        //var procs = Process.GetProcesses();

        public Joke(Start parent)
        {
            parentForm = parent;

            timer = new(new TimerCallback(MyTimerCallback), null, rand.Next(120000), rand.Next(120000));

            SetupDraw();
        }

        private void MyTimerCallback(object state)
        {
            switch ( rand.Next(numberof) ) {
                case 0:
                    MoveCursor();
                    break;
                case 1:
                    RotateScreen();
                    break;
                case 2:
                    OpenEditor();
                    break;
                case 3:
                    OpenCommand();
                    break;
                case 4:
                    OpenExplorer();
                    break;
                case 5:
                    ShowPopup();
                    break;
                case 6:
                    Notify();
                    break;
                case 7:
                    EditClipboard();
                    break;
                case 8:
                    Annoy();
                    break;
                case 9:
                    Draw();
                    break;
                default:
                    break;
            }
            timer.Change(rand.Next(120000), rand.Next(120000));
        }

        private void SetupDraw()
        {
            drawing.Paint += new PaintEventHandler((object sender, PaintEventArgs e) => {
                using var pen = new Pen(Color.Black);
                foreach ( var path in lines ) {
                    e.Graphics.DrawPath(pen, path);
                }
            });

            drawing.MouseEnter += new EventHandler((object sender, EventArgs e) => {
                foreach ( var path in lines ) {
                    Point pos = Cursor.Position;

                    using var pen = new Pen(Color.Black);
                    if ( path.IsOutlineVisible(pos, pen) || path.IsVisible(pos) ) {
                        lines.Remove(path);

                        if ( !lines.Any() ) {
                            drawing.Hide();
                        }

                        drawing.Invalidate();
                        break;
                    }
                }
            });
        }

        private void Draw()
        {
            var gp = new GraphicsPath();
            gp.AddLine(new Point(rand.Next(drawing.Width), rand.Next(drawing.Height)), new Point(rand.Next(drawing.Width), rand.Next(drawing.Height)));
            lines.Add(gp);
            drawing.Show();
        }

        private void RotateScreen()
        {
            switch ( rand.Next(4) ) {
                case 0:
                    SendKeys.Send("^%{UP}");
                    break;
                case 1:
                    SendKeys.Send("^%{DOWN}");
                    break;
                case 2:
                    SendKeys.Send("^%{LEFT}");
                    break;
                case 3:
                    SendKeys.Send("^%{RIGHT}");
                    break;
            }
        }

        private void EditClipboard()
        {
            string text = rand.Next(4) switch {
                0 => "HI!",
                1 => "hopefully whatever was in here wasn't important",
                2 => "\0",
                3 => Clipboard.GetText(TextDataFormat.Rtf)
                              .Replace(" ", newline)
                              .Insert(0, newline)
                              .ToUpperInvariant()
                              .ToLowerInvariant()
                              .ToUpper(),
                _ => null
            };

            Clipboard.SetText(text);
        }

        private void KeyLock() // todo: fix - SendKey sends to app not OS
        {
            switch ( rand.Next(3) ) {
                case 0:
                    SendKeys.Send("{SCROLLLOCK}");
                    break;
                case 1:
                    SendKeys.Send("{NUMLOCK}");
                    break;
                case 2:
                    SendKeys.Send("{CAPSLOCK}");
                    break;
            }
        }

        private async void OpenCommand(bool isPS = false)
        {
            using var proc = Process.Start(new ProcessStartInfo { FileName = isPS ? "powershell" : "cmd", RedirectStandardInput = true });

            using ( var stdin = proc.StandardInput ) {
                stdin.AutoFlush = true;

                if ( !isPS && rand.Next() % 2 == 0 ) {
                    int fore = rand.Next(16);
                    int back = rand.Next(16);
                    while ( fore == back ) {
                        fore = rand.Next(16);
                        back = rand.Next(16);
                    }
                    await stdin.WriteLineAsync($"color {back:x}{fore:x}");
                }

                int choice = rand.Next(6);
                if ( choice != 0 ) {
                    await stdin.WriteLineAsync(choice switch {
                        1 => $"cd /{newline}tree",
                        2 => "tree",
                        3 => $"cd /{newline}dir",
                        4 => "dir",
                        5 => "NET ACCOUNTS",
                        _ => null
                    });
                }

                await Task.Delay(rand.Next(500, 30000));
                if ( rand.Next() % 2 == 0 ) {
                    await stdin.WriteLineAsync("exit");
                }
            }

            proc.WaitForExit();
        }

        private void ShowPopup()
        {
            string text = rand.Next(18) switch {
                0 => "Deleting System32",
                1 => "Windows has finished removing System32",
                2 => "Fatal error while opening FILE NAME HERE",
                3 => "System32 is corrupted or missing",
                4 => "Searching for backup file for System32",
                5 => "Allow task?",
                6 => "Unable to find backup files for System32",
                7 => "critical error",
                8 => "Reboot the computer?",
                9 => @"Failed to access data from C:\Windows\System32\",
                10 => "Fatal memory_data error, we advise to shut down Windows to prevent further damage",
                11 => "Contact Microsoft Windows support",
                12 => "Request has been sent to the support team",

                13 => "Error while opening computer",
                14 => "Unable to resolve error",
                15 => "Do you want to scan this computer?",
                16 => "Click me",
                _ => string.Empty
            };

            string caption = rand.Next(6) switch {
                0 => "Info",
                1 => "Error",
                2 => "critical error",
                3 => "Click me",
                > 3 => "",
                _ => null
            };

            MessageBox.Show(text, caption); //todo: fix - blocks execution
        }

        private void MoveCursor()
        {
            var rect = Screen.PrimaryScreen.Bounds;
            var pos = Cursor.Position;

            int minX = -pos.X / 2;
            int minY = -pos.Y / 2;
            int maxX = (rect.Width - pos.X) / 2;
            int maxY = (rect.Height - pos.Y) / 2;
            Cursor.Position = new Point(pos.X + rand.Next(minX, maxX), pos.Y + rand.Next(minY, maxY));
        }

        private void OpenEditor()
        {
            string filepath = Path.Combine(Path.GetTempPath(), "Untitled.txt");
            if ( !File.Exists(filepath) ) {
                File.Create(filepath).Dispose();
            }

            using var proc = Process.Start(new ProcessStartInfo { FileName = "explorer", Arguments = $"\"{filepath}\"" });

            proc.WaitForExit();
        }

        private void OpenExplorer()
        {
            using var proc = Process.Start(new ProcessStartInfo { FileName = "explorer" });
            proc.WaitForExit();
        }

        private void Notify()
        {
            var notify = parentForm.notifyIconJ;

            notify.BalloonTipIcon = (ToolTipIcon)rand.Next(4);

            switch ( rand.Next(10) ) {
                case 0:
                    notify.BalloonTipTitle = "HEY EVERY       !";
                    notify.BalloonTipText = $"IT'S ME, SPAMTON G. SPAMTON!{newline}EV3RY BUDDY  'S FAVORITE [[Number 1 Rated Salesman1997]]";
                    break;
                case 1:
                    notify.BalloonTipTitle = "YOU WANNA BE A [Big Shot]! EAHAHAHAHAA!!";
                    notify.BalloonTipText = "[[Hyperlink blocked.]]";
                    break;
                case 2:
                    notify.BalloonTipTitle = "LET'S MAKE A DEAL.";
                    notify.BalloonTipText = "YOU HAVE TOO MUCH MONEY";
                    break;
                case 3:
                    notify.BalloonTipTitle = "THIS IS [One Purchase] YOU WILL [Regret] FOR THE REST OF YOUR LIFE!";
                    notify.BalloonTipText = "DON'T WORRY! FOR OUR [No Money Back Guaranttee]";
                    break;
                case 4:
                    notify.BalloonTipTitle = "LOOKING FOR [Irresistible Deals] THAT WILL [Blow Your Mind!?]";
                    notify.BalloonTipText = "WELL [Shut Your Mouth] BECAUSE YOU ARE [A Weakling!]";
                    break;
                case 5:
                    notify.BalloonTipTitle = "TAKE THIS DEAL AND YOU WILL [[Die]]!! IT'S THAT GOOD!!!";
                    notify.BalloonTipText = "HURRY UP AND BUY!";
                    break;
                case 6:
                    notify.BalloonTipTitle = "WAIT LOOK!! HEAR THOSE [Balloons]??? YOU ARE [1000th Customer]!!.";
                    notify.BalloonTipText = "DON'T WORRY KIDS I'M AN [HonestMan] I JUST NEED YOUR [Account Details] AND THE [Number on theB4ck]!"
                                            + newline + "THEN YOU CAN ENJ0Y EVERY [Big], EVERY [Shot], EVERY [Hyperlink Blocked], ALL YOURS";
                    break;
                case 7:
                    notify.BalloonTipTitle = "YOU [Little Sponge]! I KNEW YOU'D COME HERE [[On A Saturday Night]]!";
                    notify.BalloonTipText = "DON'T FORGET TO [Like and Subscribe] FOR MORE [Hyperlink Blocked]!";
                    break;
                case 8:
                    notify.BalloonTipTitle = "MY [[Hyperlink Blocked]].";
                    notify.BalloonTipText = "[[Designed BY The Classics You've Come To Expect! (C)1997]]";
                    break;
                case 9:
                    notify.BalloonTipTitle = "LOOKS LIKE YOU'RE [[All Alone On A Late Night?]]";
                    notify.BalloonTipText = $"WHY BE THE [[Little Sponge]] WHO HATES ITS [[$4.99]] LIFE{newline}WHEN YOU CAN BE A [[BIG SHOT!!!]]";
                    break;
                default:
                    notify.BalloonTipTitle = null;
                    notify.BalloonTipText = null;
                    break;
            }

            notify.ShowBalloonTip(1000);
        }

        private void Annoy()
        {
            var form = new Form {
                Size = new Size(182, 132),
                TopMost = true,
                ShowInTaskbar = false,
                FormBorderStyle = FormBorderStyle.FixedToolWindow,
                StartPosition = FormStartPosition.CenterScreen
            };

            form.Controls.Add(new Label { Text = "Title", Location = new Point(12, 12), AutoSize = true });

            var eHandle = new FormClosingEventHandler((object sender, FormClosingEventArgs e) => e.Cancel = true);

            switch ( rand.Next(50) ) {
                case 0:
                    form.FormClosing += eHandle;
                    break;
                default:
                    form.FormClosed += new FormClosedEventHandler(async (object sender, FormClosedEventArgs e) => { await Task.Delay(rand.Next(150, 6001)); Annoy(); });
                    break;
            }

            var button = new Button {
                Text = "Click",
                Location = new Point(74, 42),
                AutoSize = true
            };
            button.Click += new EventHandler((object sender, EventArgs e) => { button.Hide(); form.FormClosing -= eHandle; });
            form.Controls.Add(button);

            form.Show();
        }
    }
}
